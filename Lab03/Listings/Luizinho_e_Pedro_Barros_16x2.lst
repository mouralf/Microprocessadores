C51 COMPILER V9.60.0.0   LUIZINHO_E_PEDRO_BARROS_16X2                                      08/21/2021 18:29:36 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE LUIZINHO_E_PEDRO_BARROS_16X2
OBJECT MODULE PLACED IN .\Objects\Luizinho_e_Pedro_Barros_16x2.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE Luizinho_e_Pedro_Barros_16x2.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTE
                    -ND PRINT(.\Listings\Luizinho_e_Pedro_Barros_16x2.lst) TABS(2) OBJECT(.\Objects\Luizinho_e_Pedro_Barros_16x2.obj)

line level    source

   1          //Lab 3 de Microprocessadores
   2          //Turma D
   3          //Luiz Felipe de Moura 00305017
   4          //Pedro Barros Baitelli 00304123
   5          
   6          #include <stdio.h>
   7          
   8          char xdata LISTA[] = {
   9          'N','Y','A','H',' ','H','U','S','T','O','N',0, 7, 90, 9, 11, 9, 9, 0, 0, 0, 0, 0, 0, 0, 0,  //7,90; 9,11; 
             -0,0; 0,0; 0, 0; 0,0
  10          'J','A','G','G','E','R',' ','E','A','T','O','N',0, 8, 20, 9, 5, 0, 0, 8, 70,9,40, 0, 0, 0, 0, //8,20; 9,05
             -; 0,0; 8,70; 9,40; 0,0; 0,0
  11          'G','U','S','T','A','V','O',' ','R','I','B','E','I','R','O',0, 7, 23, 5, 82, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
             -  //7,23; 5,82; 0,0; 0,0; 0,0; 0,0; 2,0
  12          'K','E','L','V','I','N',' ','H','O','E','F','L','E','R',0, 8, 98, 8, 84, 8, 99, 0, 0, 0, 0, 7,58, 9,34, //
             -8,98; 8,84; 8,99; 0,0; 0,0; 7,58; 9,34
  13          'V','I','C','E','N','T',' ','M','I','L','O','U',0, 7, 87, 5, 54, 9, 23, 0, 0, 8, 34, 0,0, 8,70, //7,87; 5,
             -54; 9,23; 0,0; 8,34; 0,0; 8,70
  14          'A','N','G','E','L','O',' ','N','A','R','V','A','E','Z',0, 7, 1, 6, 9, 9, 0, 0, 0, 0, 0, 8,65, 8,21, //7,0
             -1; 6,89; 9,00; 0,0; 0,0; 8,65; 8,21
  15          'A','U','R','E','L','I','A','N',' ','G','R','A','U','D',0, 4, 21, 7, 20, 8, 68, 0, 0, 9, 0, 0, 0, 0, 0, //
             -4,21; 7,20; 8,68; 0,0; 9,0; 0,0;
  16          'Y','U','T','O',' ','H','O','R','I','G','A','M','E',0, 8, 02, 6, 77, 9, 3, 0, 0, 9, 35, 9, 50, 9,30 //8,02
             -; 6,77; 9,03; 0,0; 9,35; 9,50; 9,30
  17          };
  18          
  19          
  20          char xdata RESULT[100] ;
  21          
  22          //AS QUATRO MELHORES NOTAS SÃO SOMADAS PARA DETERMINAR A PONTUAÇÃO
  23          
  24          void main()
  25          {
  26   1        unsigned char indiceLista = 0; //variável para controlar a posição na lista
  27   1        unsigned int notasTemporarias[7]; //variavel para auxiliar no armazenamento das notas
  28   1        char nomeCompetidor[8][8]; //matriz para armazenar o índice e o nome do competidor
  29   1        unsigned int notasFinais[8]; //matriz para armazenar as notas dos competidores
  30   1        unsigned char  numCompetidor, letrasNome, indiceNota,indiceNotaLista, k, j; //variáveis para auxiliar a a
             -rmazenar notas e nome
  31   1        unsigned int aux; //variável auxiliar
  32   1        int notaOuro, notaPrata, notaBronze; //variáveis para armazenar as melhores notas do podio
  33   1        unsigned char indiceOuro , indicePrata, indiceBronze; //variáveis para armazenar os índices do pódio
  34   1        
  35   1        
  36   1        for (numCompetidor = 0; numCompetidor<8; numCompetidor++){ //for para percorrer a lista
  37   2          letrasNome = 0; //para armazenar as letras do nome, será resetado a cada vez que for ler os dados de um 
             -competidor
  38   2          
  39   2          /*le o nome do competidor até chegar no 0*/
  40   2          do{
  41   3            
  42   3            nomeCompetidor[numCompetidor][letrasNome] = LISTA[indiceLista]; //armazena as letras do nome na matriz 
             -adequada
  43   3            letrasNome++; //incrementa as letras do nome
C51 COMPILER V9.60.0.0   LUIZINHO_E_PEDRO_BARROS_16X2                                      08/21/2021 18:29:36 PAGE 2   

  44   3            indiceLista++; //incrementa o indice da lista
  45   3          }while(LISTA[indiceLista-1] != ' ');
  46   2          
  47   2          while(LISTA[indiceLista] != 0){
  48   3            indiceLista++;
  49   3          }
  50   2          indiceLista++;  //incrementa o indice da lista
  51   2      
  52   2          indiceNota = 0; //para ser incrementado e pegar as notas
  53   2      
  54   2          for (indiceNotaLista = 0; indiceNotaLista<7; indiceNotaLista++){ //percorre a lista para pegar as notas
  55   3            notasTemporarias[indiceNota] = LISTA[indiceLista]*100 + LISTA[indiceLista+1]; //pega as notas temporari
             -as e armazena
  56   3            indiceNota++;
  57   3            indiceLista+=2;
  58   3            
  59   3          } //fecha o for que le as notas
  60   2              
  61   2      
  62   2          /*ordena as 7 notas em ordem decrescente*/
  63   2          for (k = 1; k < 8; k++) {
  64   3              
  65   3              for (j = 0; j < 7; j++) {
  66   4      
  67   4                  if (notasTemporarias[j] > notasTemporarias[j + 1]) {
  68   5                      aux = notasTemporarias[j];
  69   5                      notasTemporarias[j] = notasTemporarias[j + 1];
  70   5                      notasTemporarias[j + 1] = aux;
  71   5                  }
  72   4              }
  73   3          }
  74   2          
  75   2          
  76   2          
  77   2          //pega só as 4 maiores notas de cada competidor
  78   2          notasFinais[numCompetidor] = (notasTemporarias[6]+notasTemporarias[5]+notasTemporarias[4]+notasTemporari
             -as[3]);
  79   2        
  80   2        }//fecha o for que percorre LISTA[]
  81   1        
  82   1        /* pega as maiores notas para definir o podio */
  83   1        for(numCompetidor = 0; numCompetidor < 8; numCompetidor++){
  84   2                  if(notasFinais[numCompetidor]>notaOuro){ //se a nota lida for maior que a nota antiga do Ouro
  85   3                    //redefine o bronze para os valores antigos do prata
  86   3                    notaBronze = notaPrata;   
  87   3                    indiceBronze = indicePrata; 
  88   3                    //redefine o prata para os valores antigos do ouro
  89   3                    notaPrata = notaOuro;
  90   3                    indicePrata= indiceOuro;
  91   3                    //redefine os novos valores para o ouro
  92   3                    notaOuro = notasFinais[numCompetidor];
  93   3                    indiceOuro = numCompetidor;
  94   3                      
  95   3                  } else if (notasFinais[numCompetidor]>notaPrata){ //caso a nota seja maior que a nota antiga d
             -o Prata
  96   3                    //redefine o bronze para os valores antigos do prata
  97   3                    notaBronze = notaPrata;   
  98   3                    indiceBronze = indicePrata; 
  99   3                    //redefine os novos valores para o prata
 100   3                    notaPrata = notasFinais[numCompetidor];
 101   3                    indicePrata = numCompetidor;
 102   3                  } 
C51 COMPILER V9.60.0.0   LUIZINHO_E_PEDRO_BARROS_16X2                                      08/21/2021 18:29:36 PAGE 3   

 103   2                   else if (notasFinais[numCompetidor]>notaBronze){ //se a nota for maior que a nota antiga do Bronze
 104   3                    //redefine os novos valores para o bronze
 105   3                    notaBronze = notasFinais[numCompetidor];
 106   3                    indiceBronze = numCompetidor;
 107   3                  }
 108   2          }
 109   1          
 110   1          aux = 0;
 111   1          for (k = 0; k<3; k++){ //pega as duas melhores notas para o podio
 112   2            
 113   2            if( k == 0){ //pega o índice do ouro
 114   3              j = indiceOuro;
 115   3            }else if( k == 1){ //pega o índice do prata
 116   3              j = indicePrata;
 117   3            } else if (k == 2){ //pega o índice do bronze
 118   3              j = indiceBronze;
 119   3            }
 120   2            
 121   2            letrasNome = 0;
 122   2            //pega o nome de cada competidor do podio
 123   2            while (nomeCompetidor[j][letrasNome] != ' '){
 124   3              RESULT[aux] = nomeCompetidor[j][letrasNome]; //armazena em RESULT o nome do competidor (ordem de podio
             -)
 125   3              aux++;
 126   3              letrasNome++;
 127   3          }
 128   2            RESULT[aux+1] = notasFinais[j]/1000; //armazena em RESULT o dígito da dezena
 129   2            RESULT[aux+2] = (notasFinais[j]/100)%10; //armazena em RESULT o dígito da unidade
 130   2            RESULT[aux+3] = ',';
 131   2            RESULT[aux+4] = (notasFinais[j]-(notasFinais[j]/100)*100)/10; ////armazena em RESULT o dígito da dezena
             - após a vírgula
 132   2            RESULT[aux+5] = (notasFinais[j]-(notasFinais[j]/100)*100)%10; //armazena em RESULT o dígito da unidade 
             -após a virgula
 133   2            aux+=6;   
 134   2          }
 135   1          
 136   1          
 137   1      while(1) ; // Final do programa 
 138   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    727    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =    325    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----     109
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
